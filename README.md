# JAVA-
一些关于Java面试的学习
### 理解static
[参考链接](http://www.cnblogs.com/dolphin0520/p/3799052.html)
#### static方法
静态方法**不依赖于任何对象**就可以进行访问，因此没有this，*在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用*。例如：main方法就是static，因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。
#### static变量
静态变量和非静态变量的区别是：静态变量被**所有的对象所共享**，它当且仅当在类初次**加载时会被初始化**。而非静态变量是**对象**所拥有的，在**创建对象**的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。static成员变量的初始化顺序**按照定义的顺序**进行初始化。
#### static代码块
static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。
*因为静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。*
### final关键字 ###
final修饰类不能被继承，修饰方法不能被重写。（可以重载）修饰变量，只能被赋值一次，必须要初始化。
### 方法重写和方法重载 ###
***方法重写***：若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。用super关键字访问父类方法。
***方法重载***：同一个类的相同名称的方法，参数类型，个数，顺序不完全相同。**只有返回值不同是不构成 方法重载**。
### Java中的构造方法和构造方法重载
***构造方法***：为了初始化对象，构造函数的函数名和类名一致。构造方法的重载类似于方法重载，参数列表不同。
### Java支持多继承？ ###
Java只支持单继承，出于对安全性的考虑。
### 接口和抽象类的区别 ###

***抽象类***：是含有抽象方法（abstact修饰的方法，只声明，没有具体实现）的类。抽象类不能创建对象，抽象类是为了继承而存在的。

***接口***：一种特殊的抽象类，接口中的方法必须全是抽象方法（必须是public abstract修饰）接口中的变量必须是public abstract final修饰。

***区别***：
1 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
2 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
3 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
4 一个类只能继承一个抽象类，而一个类却可以实现多个接口。
### 值传递和引用传递 ###
值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.
引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。
一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递
### 线程和进程的区别 ###
进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。
一个线程只能属于一个进程，但是一个进程可以拥有多个线程。多线程处理就是允许一个进程中在同一时刻执行多个任务。
在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如**管道，信号，消息队列，共享内存，套接字**等通信机制，而线程由于共享数据段所以通信机制很方便。
地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
### 创建线程的不同方式 ###
1.继承thread类
2.实现runnable接口，重写run方法
3.使用Executor框架创建线程池。Executor框架是juc里提供的线程池的实现
### 介绍线程的可用状态 ###
1.新建(new)：新创建了一个线程对象。
2.可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权。
3.运行(running)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice ），执行程序代码。
4.阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有     机会再次获得cpu timeslice 转到运行(running)状态。

等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join ()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

5.死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。
### 同步方法和同步代码块的区别是什么？ ### 
同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用   synchronized（object）{代码内容}进行修饰；
### 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？ ###

