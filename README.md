# JAVA-
一些关于Java面试的学习
### 理解static
[参考链接](http://www.cnblogs.com/dolphin0520/p/3799052.html)
#### static方法
静态方法**不依赖于任何对象**就可以进行访问，因此没有this，*在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用*。例如：main方法就是static，因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。
#### static变量
静态变量和非静态变量的区别是：静态变量被**所有的对象所共享**，它当且仅当在类初次**加载时会被初始化**。而非静态变量是**对象**所拥有的，在**创建对象**的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。static成员变量的初始化顺序**按照定义的顺序**进行初始化。
#### static代码块
static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。
*因为静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。*
### final关键字 ###
final修饰类不能被继承，修饰方法不能被重写。（可以重载）修饰变量，只能被赋值一次，必须要初始化。
### 方法重写和方法重载 ###
***方法重写***：若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。用super关键字访问父类方法。
***方法重载***：同一个类的相同名称的方法，参数类型，个数，顺序不完全相同。**只有返回值不同是不构成 方法重载**。
### Java中的构造方法和构造方法重载
***构造方法***：为了初始化对象，构造函数的函数名和类名一致。构造方法的重载类似于方法重载，参数列表不同。
### Java支持多继承？ ###
Java只支持单继承，出于对安全性的考虑。
### 接口和抽象类的区别 ###

***抽象类***：是含有抽象方法（abstact修饰的方法，只声明，没有具体实现）的类。抽象类不能创建对象，抽象类是为了继承而存在的。

***接口***：一种特殊的抽象类，接口中的方法必须全是抽象方法（必须是public abstract修饰）接口中的变量必须是public abstract final修饰。

***区别***：
1 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
2 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
3 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
4 一个类只能继承一个抽象类，而一个类却可以实现多个接口。
### 值传递和引用传递 ###
值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.
引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。
一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递
### 线程和进程的区别 ###
进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。
一个线程只能属于一个进程，但是一个进程可以拥有多个线程。多线程处理就是允许一个进程中在同一时刻执行多个任务。
在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如**管道，信号，消息队列，共享内存，套接字**等通信机制，而线程由于共享数据段所以通信机制很方便。
地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
### 创建线程的不同方式 ###
1.继承thread类
2.实现runnable接口，重写run方法
3.使用Executor框架创建线程池。Executor框架是juc里提供的线程池的实现
### 介绍线程的可用状态 ###
1.新建(new)：新创建了一个线程对象。
2.可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权。
3.运行(running)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice ），执行程序代码。
4.阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有     机会再次获得cpu timeslice 转到运行(running)状态。

等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join ()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

5.死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。
### 同步方法和同步代码块的区别是什么？ ### 
同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用   synchronized（object）{代码内容}进行修饰；
### 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？ ###
监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。
### 什么是死锁 ###
**死锁** :是指两个或两个以上的进程在执行过程中,因**争夺资源**而造成的一种**互相等待**的现象,若无**外力作用**,它们都将无法推进下去
死锁的四个**必要条件**： 互斥条件，不剥夺条件，循环等待条件，请求与保持条件
### 如何确保N个线程可以访问N个资源同时又不导致死锁？ ###
多线程产生死锁需要四个条件，分别是互斥性，保持和请求，不可剥夺性还有要形成闭环，这四个条件缺一不可，只要破坏了其中一个条件就可以破坏死锁，其中最简单的方法就是线程都是以同样的顺序加锁和释放锁，也就是破坏了第四个条件。
### Java集合类框架的基本接口有哪些？###
总共有两大接口：Collection 和Map ，一个元素集合，一个是键值对集合； 其中List和Set接口继承了Collection接口，一个是有序元素集合，一个是无序元素集合； 而ArrayList和 LinkedList 实现了List接口，HashSet实现了Set接口，这几个都比较常用； HashMap 和HashTable实现了Map接口，并且HashTable是线程安全的，但是HashMap性能更好；
### 什么是迭代器 ###
迭代器是一种设计模式，它是一个对象，**它可以遍历并选择序列中的对象**，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。terator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。
### Iterator和ListIterator的区别是什么？ ###
Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。
### Java中的HashMap的工作原理是什么？ ###
ashMap的底层是用hash数组和单向链表实现的 ，当调用put方法是，首先计算key的hashcode，定位到合适的数组索引，然后再在该索引上的单向链表进行循环遍历用equals比较key是否存在，如果存在则用新的value覆盖原值，如果没有则向后追加。HashMap的两个重要属性是容量capacity和加载因子loadfactor，默认值分布为16和0.75，当容器中的元素个数大于 capacity*loadfactor时，容器会进行扩容resize 为2n
### hashmap和 hashtable 区别 ###
1、HashMap是非线程安全的，HashTable是线程安全的。

2、HashMap的键和值都允许有null值存在，而HashTable则不行。

3、因为线程安全的问题，HashMap效率比HashTable的要高。
4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。

    一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。
